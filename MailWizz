# MailWizz Infrastructure Automation - Complete Implementation Specification

## System Overview
Automated synchronization system that reads a CSV file containing domain and IP allocations, generates unique non-enumerable hostnames, and provisions complete email infrastructure including PowerMTA, DNS, mailboxes, and MailWizz database records.

Accurate Complete Bridge per Specification:
new.csv â†’ IP distributor (MAX_IPS_PER_DOMAIN from config.sh) â†’ enhanced-generator â†’ zone_parser â†’ modified powermta script â†’ PowerMTA/DKIM configs â†’ DNS records â†’ Mailboxes â†’ MailWizz DB
Per the MD specification:

new.csv - Input with domains and CIDR blocks
IP distributor - Uses config.sh settings (MAX_IPS_PER_DOMAIN, IP_DISTRIBUTION_MODE)
enhanced-generator.sh - Generates non-enumerable hostnames
zone_parser.sh - Creates synchronized line files
Modified powermta--vmta_configs.sh - Reads enhanced hostnames from zone_parser output
powermta--generate_dkim_add_to_configs.sh - Creates DKIM keys
DNS updates - Generate updates.txt for cloudflare--dns_management.sh
exim_mailbox.sh - Creates bounce@ and fbl@ mailboxes
mailwizz_db.sh - Syncs everything to database

All configurable via config.sh parameters, not hardcoded values.

## System Architecture

### Configuration Management

#### config.sh (Master Configuration File)
```bash
#!/bin/bash
# Master Configuration File for MailWizz Infrastructure Automation
# All operational parameters are defined here

# IP Distribution Settings
MAX_IPS_PER_DOMAIN=30          # Maximum IPs allocated per domain (configurable)
IP_DISTRIBUTION_MODE="even"     # Options: even | weighted | manual
IP_ALLOCATION_FILE=""           # Path to custom allocation file if mode=manual
MIN_IPS_PER_DOMAIN=1           # Minimum IPs per domain
IP_SHUFFLE_ENABLED=true        # Shuffle IPs for non-sequential assignment

# PowerMTA Settings
PMTA_PORT=10025
PMTA_CONFIG_PATH="/etc/pmta/config"
PMTA_BACKUP_RETAIN_DAYS=30
PMTA_MAX_MSG_RATE="5/m"        # Default rate limiting
PMTA_TIMEOUT=30
PMTA_FOLDER_STRUCTURE=true     # Create organized folder structure

# DKIM Settings
DKIM_KEY_SIZE=2048              # Key size in bits (1024, 2048, 4096)
DKIM_SELECTOR="key1"            # DKIM selector
DKIM_PRIVATE_PATH="/etc/pmta/domainkeys"
DKIM_PUBLIC_PATH="/etc/publickeys"
DKIM_BACKUP_KEYS=true          # Backup existing keys before generation

# DNS Settings
DNS_TTL=300                     # Default TTL for all records
DNS_BATCH_SIZE=100             # Records per batch for API calls
DNS_RETRY_ATTEMPTS=3           # Retry attempts for failed operations
PTR_REQUEST_BATCH=50           # PTR records per request to ISP
DNS_VERIFY_PROPAGATION=true    # Verify DNS propagation after creation

# Database Settings
DB_HOST="localhost"
DB_NAME="mailwizz"
DB_USER="mailwizz"
DB_PASS=""                     # Set via environment variable
DB_BATCH_SIZE=50              # Records per transaction
DB_TRANSACTION_TIMEOUT=300     # Timeout in seconds
DB_BACKUP_BEFORE_SYNC=true    # Backup database before changes

# Mailbox Settings
BOUNCE_PREFIX="bounce"         # Prefix for bounce mailboxes
FBL_PREFIX="fbl"              # Prefix for FBL mailboxes
MAILBOX_PATH="/var/mail/virtual"
IMAP_PORT=143
DOVECOT_USER="vmail"
DOVECOT_GROUP="vmail"
MAILBOX_QUOTA="1G"            # Quota per mailbox

# Pool Naming Settings
POOL_PREFIX="mailwizz"         # Prefix for pool names
POOL_USE_TIMESTAMP=true        # Include timestamp in pool names
POOL_SEPARATOR="_"             # Separator character
POOL_TEMPLATE="${POOL_PREFIX}${POOL_SEPARATOR}\${DOMAIN}${POOL_SEPARATOR}\${TIMESTAMP}"

# Quota Settings (MailWizz Delivery Servers)
HOURLY_QUOTA=1000
DAILY_QUOTA=10000
MONTHLY_QUOTA=0               # 0 = unlimited
PAUSE_AFTER_SEND=0            # Milliseconds to pause

# Warmup Settings
USE_WARMUP_PLAN=false         # Enable warmup plan assignment
DEFAULT_WARMUP_PLAN_ID=""     # Default warmup plan ID

# State Management
STATE_DIR="./state"
LOG_DIR="./logs"
BACKUP_DIR="./backups"
REPORT_DIR="./reports"
DEBUG_MODE=false              # Enable debug logging

# API Settings
CLOUDFLARE_API_SLEEP=1        # Sleep between API calls
CLOUDFLARE_ACCOUNTS_FILE="./cloudflare_accounts.json"

# Validation Settings
VALIDATE_DNS=true             # Validate DNS after creation
VALIDATE_PMTA=true            # Validate PowerMTA configs
VALIDATE_MAILBOX=true         # Validate mailbox creation
VALIDATE_DATABASE=true        # Validate database entries

# Enhanced Generator Settings
ENHANCED_STYLES=15            # Number of naming styles to use
ENHANCED_ENTROPY_POOLS=true  # Use expanded entropy pools
ENHANCED_STATE_FILE="./state/used_names.json"
```

### Component Integration
```
CSV Input â†’ IP Expansion â†’ Enhanced Generator â†’ Zone Parser â†’ PowerMTA Config
                                              â†“              â†“
                                          DNS Records    Mailboxes
                                              â†“              â†“
                                          PTR Records   MailWizz DB
```

### Existing Scripts Being Integrated

#### 1. enhanced-generator.sh
**Purpose:** Generates unique, non-enumerable hostnames using 15+ naming patterns
**Current Operation:**
- Reads IP ranges in CIDR format with domain assignment
- Generates cryptographically random hostnames
- Maintains uniqueness across all generated names via state file
- Outputs BIND zone file format
**Naming Patterns Include:**
1. Random alphanumeric (8 chars): `qh873a5f`
2. Word combinations: `storm95kt`, `mesh127-89`
3. Chemical formulas with numbers: `h2o5-7fc`
4. Technical prefixes: `nexu-142`, `node-8f3c4a`
5. Astronomy terms: `nova-7x2`, `star-4821`
6. Network terms: `relay-9k3m`, `gate-5p2q`
7. Abstract combinations: `flux89-2a`, `sync-4m7n`
8. Element codes: `xe92-7h3`, `kr15-9d2`
9. Time-based: `t2024-8a3`, `d365-4k9`
10. Matrix references: `mx8-7291`, `grid-3847`
11. Quantum terms: `q7-spin4`, `entg-8392`
12. Hybrid alphanumeric: `7k2-mare`, `3h9-bolt`
13. Encoded patterns: `enc8x92m`, `b64h7k3n`
14. Geometric terms: `tri8-2k4`, `hex-9384`
15. Musical references: `c7-maj9`, `a440-3hz`
**Integration Notes:**
- Core component providing ALL hostnames
- No predictable patterns anywhere in the system
- Output feeds directly into zone parser

#### 2. powermta--vmta_configs.sh (Modified for Enhanced Hostnames)
**Purpose:** Generates PowerMTA virtual-mta configurations
**Current Operation:**
- Creates folder structure: /etc/pmta/configs/{domain}/{mailer#}/
- Generates individual config files per IP
- Uses vmta naming pattern: {domain}.c{last_digit_3rd_octet}.{4th_octet}
**Required Modifications:**
- REMOVE all predictable hostname generation
- READ enhanced hostnames from zone parser output
- MAINTAIN vmta naming for internal reference only
- USE enhanced hostnames for all smtp-source-host directives
**New Behavior:**
```xml
<!-- OLD (predictable - DO NOT USE) -->
<virtual-mta domain1.net.c6.15>
smtp-source-host 6.6.6.15 mailer6-vmta-6-15.domain1.net
</virtual-mta>

<!-- NEW (enhanced hostnames only) -->
<virtual-mta domain1.net.c6.15>
smtp-source-host 6.6.6.15 qh873a5f.domain1.net
</virtual-mta>
```

#### 3. powermta--generate_dkim_add_to_configs.sh (Modified)
**Purpose:** Generates DKIM keys and signing directives
**Current Operation:**
- Generates RSA keys for each unique domain
- Creates private keys in /etc/pmta/domainkeys/key1_dkim.{domain}.pem
- Creates public keys in /etc/publickeys/public_key1_dkim.{domain}.pem
- Strips headers and line breaks from public keys
**Required Modifications:**
- Use configurable key size from config.sh
- Create JSON export for database import
- Add state tracking for generated keys
- Maintain backup of existing keys

#### 4. cloudflare--dns_management.sh
**Purpose:** Manages DNS records via Cloudflare API
**Current Operation:**
- Supports multiple Cloudflare accounts
- Reads updates.txt with format: name ttl class type value operation
- Operations: create, update, delete, proxyon, proxyoff
- Batch processing with --no-confirm flag
**Integration:**
- Processes ALL enhanced hostnames
- No modifications to predictable patterns (there are none)
- Handles A, PTR, TXT, SPF records

### New Components Being Created

#### 5. zone_parser.sh (Critical Integration Component)
**Purpose:** Converts enhanced-generator zone output to line files
**Operations:**
- Parses BIND zone format
- Extracts IP, hostname, domain information
- Creates synchronized line files
- Generates vmta_mapping.json
**Critical Requirement:** Maintains exact line order synchronization
```bash
#!/bin/bash
# zone_parser.sh - Converts zone file to synchronized line files

input_zone="$1"
output_dir="./parsed"
mkdir -p "$output_dir"

# Clear output files
> "$output_dir/ip.txt"
> "$output_dir/hostname.txt"
> "$output_dir/domain.txt"
> "$output_dir/third_octet.txt"
> "$output_dir/fourth_octet.txt"
> "$output_dir/last_digit_third.txt"

# Parse zone file maintaining order
while read line; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$line" ]] && continue
    
    # Extract components from zone record
    hostname=$(echo "$line" | awk '{print $1}' | sed 's/\.$//')
    ip=$(echo "$line" | awk '{print $5}')
    
    # Skip if not a valid A record
    [[ ! "$line" =~ "IN A" ]] && continue
    
    # Extract domain (last two parts of hostname)
    domain=$(echo "$hostname" | rev | cut -d. -f1,2 | rev)
    
    # Extract octets
    third_octet=$(echo "$ip" | cut -d. -f3)
    fourth_octet=$(echo "$ip" | cut -d. -f4)
    last_digit_third=$(echo "$third_octet" | grep -o '.$')
    
    # Write to synchronized files (order critical!)
    echo "$ip" >> "$output_dir/ip.txt"
    echo "$hostname" >> "$output_dir/hostname.txt"
    echo "$domain" >> "$output_dir/domain.txt"
    echo "$third_octet" >> "$output_dir/third_octet.txt"
    echo "$fourth_octet" >> "$output_dir/fourth_octet.txt"
    echo "$last_digit_third" >> "$output_dir/last_digit_third.txt"
    
done < "$input_zone"

# Generate unique domain list
sort -u "$output_dir/domain.txt" > "$output_dir/domain_unique.txt"

echo "Zone parsing complete. Files created in $output_dir/"
```

#### 6. exim_mailbox.sh
**Purpose:** Creates virtual mailboxes for bounce and FBL processing
**Operations:**
- Creates Exim virtual domain directories
- Generates secure passwords for each mailbox
- Updates Dovecot user database
- Creates Maildir folder structures
- Sets proper ownership (vmail:vmail)
**Per Domain Creates:**
- bounce@domain.net mailbox (configurable prefix)
- fbl@domain.net mailbox (configurable prefix)
- Password storage for database integration

#### 7. mailwizz_db.sh
**Purpose:** Synchronizes all components to MailWizz database
**Operations:**
- Creates records in proper order for foreign key constraints
- Manages transactions for atomic updates
- Tracks state for incremental synchronization
- Validates relationships between tables
**Table Update Order:**
1. mw_tracking_domain (no dependencies)
2. mw_bounce_server (no dependencies)
3. mw_feedback_loop_server (no dependencies)
4. mw_sending_domain (no dependencies)
5. mw_delivery_server (depends on bounce & tracking)
6. mw_enhanced_hostnames (custom table for mappings)

#### 8. state_wrapper.sh
**Purpose:** Wraps existing scripts with state management
**Operations:**
- Creates checkpoints before running scripts
- Records success/failure status
- Enables resume from failure point
- Provides rollback capability

### Modular State Management

Each module maintains independent state files for targeted recovery:

**PowerMTA State (state/powermta.json):**
```json
{
  "last_update": "2024-01-15T10:00:00Z",
  "configured_ips": ["6.6.6.15", "6.6.6.3"],
  "failed_ips": [],
  "vmta_mappings": {
    "domain1.net.c6.15": "qh873a5f.domain1.net",
    "domain1.net.c6.3": "storm95kt.domain1.net"
  },
  "pool_configs": {
    "mailwizz_domain1_20240115": ["domain1.net.c6.15", "domain1.net.c6.3"]
  },
  "config_backup": "/etc/pmta/config.backup.1705316400"
}
```

**DNS State (state/dns.json):**
```json
{
  "last_update": "2024-01-15T10:05:00Z",
  "created_records": ["qh873a5f.domain1.net", "storm95kt.domain1.net"],
  "failed_records": [],
  "zones_updated": ["domain1.net", "domain2.net"],
  "ptr_requests_pending": ["6.6.6.15", "6.6.6.3"]
}
```

**Database State (state/database.json):**
```json
{
  "last_update": "2024-01-15T10:10:00Z",
  "delivery_servers_created": [1, 2, 3],
  "last_successful_id": 150,
  "failed_operations": [],
  "dkim_keys_stored": ["domain1.net", "domain2.net"]
}
```

This modular approach allows:
- Independent module execution and retry
- Precise failure identification
- Targeted rollback without affecting working components
- Clear audit trail per subsystem

### Key Operational Principles

1. **Enhanced Hostnames Only**: Every hostname is non-enumerable, no predictable patterns anywhere
2. **Configurable Everything**: All operational parameters in config.sh
3. **State Preservation**: Each module tracks its own progress, allowing resume from any failure point
4. **Foreign Key Integrity**: Database operations follow strict ordering to maintain referential integrity
5. **Validation First**: Each step validates prerequisites before making changes
6. **Incremental Updates**: System supports adding new IPs/domains without rebuilding everything

## Master Input File Format

### new.csv
```csv
domain,action,ip_range
domain1.net,enable,6.6.6.0/24
domain2.net,enable,6.6.6.0/24
domain3.net,enable,6.6.6.0/24
domain4.net,enable,6.6.6.0/24
domain5.net,enable,6.6.6.0/24
domain6.net,enable,6.6.6.0/24
domain7.net,enable,6.6.6.0/24
domain8.net,enable,6.6.6.0/24
priority.io,enable,10.10.10.0/27
```

---

# Step 1: Parse CSV and Validate Input

## Operations
Read and validate CSV file, load configuration, check format and CIDR notation.

## Implementation
```bash
#!/bin/bash
# Load master configuration
source config.sh

# Initialize counters
valid_entries=0
invalid_entries=0

# Log start
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting CSV parse: new.csv" >> "$LOG_DIR/process.log"

# Read new.csv
while IFS=',' read -r domain action ip_range; do
    # Skip header
    [[ "$domain" == "domain" ]] && continue
    
    # Skip empty lines
    [[ -z "$domain" ]] && continue
    
    # Validate CIDR format
    if [[ "$ip_range" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
        echo "Valid: $domain $action $ip_range"
        ((valid_entries++))
        
        # Validate netmask
        mask="${ip_range##*/}"
        if [[ $mask -lt 0 || $mask -gt 32 ]]; then
            echo "ERROR: Invalid netmask /$mask for $domain"
            ((invalid_entries++))
        fi
    else
        echo "ERROR: Invalid CIDR $ip_range for $domain"
        ((invalid_entries++))
    fi
done < new.csv

echo "Validation complete: $valid_entries valid, $invalid_entries invalid"
```

## Output Structure
```json
{
  "timestamp": "2024-01-15T10:00:00Z",
  "config": {
    "max_ips_per_domain": 30,
    "distribution_mode": "even",
    "pool_prefix": "mailwizz",
    "dkim_key_size": 2048
  },
  "entries": [
    {
      "domain": "domain1.net",
      "action": "enable",
      "ip_range": "6.6.6.0/24",
      "mask": 24,
      "expected_domains": 8
    },
    {
      "domain": "domain2.net",
      "action": "enable",
      "ip_range": "6.6.6.0/24",
      "mask": 24,
      "shared_with": ["domain1.net", "domain3.net", "domain4.net", "domain5.net", "domain6.net", "domain7.net", "domain8.net"]
    }
  ],
  "validation_status": "passed"
}
```

## Logging
```
[INFO] Starting CSV parse: new.csv
[INFO] Configuration loaded from config.sh
[INFO] MAX_IPS_PER_DOMAIN: 30
[INFO] IP_DISTRIBUTION_MODE: even
[INFO] Found 9 entries to process
[INFO] 8 domains sharing 6.6.6.0/24
[INFO] 1 domain with 10.10.10.0/27
[INFO] Parse complete: 9 valid entries
```

---

# Step 2: IP Range Expansion and Distribution

## IP Distribution Logic
```bash
# Load configuration for distribution limits
source config.sh

# Function to calculate IP allocation
calculate_ip_allocation() {
    local cidr="$1"
    local domain_count="$2"
    local total_ips available_ips ips_per_domain
    
    # Calculate total usable IPs
    case "${cidr##*/}" in
        24) total_ips=254 ;;  # Exclude network and broadcast
        27) total_ips=30 ;;
        *) echo "ERROR: Unsupported netmask" >&2; return 1 ;;
    esac
    
    available_ips=$total_ips
    
    # Apply distribution mode
    if [[ "$IP_DISTRIBUTION_MODE" == "even" ]]; then
        ips_per_domain=$((available_ips / domain_count))
        
        # Apply maximum limit
        if [[ $ips_per_domain -gt $MAX_IPS_PER_DOMAIN ]]; then
            ips_per_domain=$MAX_IPS_PER_DOMAIN
            echo "[INFO] Limiting to $MAX_IPS_PER_DOMAIN IPs per domain (configured maximum)"
        fi
        
    elif [[ "$IP_DISTRIBUTION_MODE" == "weighted" ]]; then
        # Read weights from domain_weights.txt
        if [[ -f "domain_weights.txt" ]]; then
            # Implement weighted distribution
            calculate_weighted_distribution "$cidr" "$domain_count"
        else
            echo "[WARN] domain_weights.txt not found, falling back to even distribution"
            ips_per_domain=$((available_ips / domain_count))
        fi
        
    elif [[ "$IP_DISTRIBUTION_MODE" == "manual" ]]; then
        # Read from allocation file
        if [[ -n "$IP_ALLOCATION_FILE" && -f "$IP_ALLOCATION_FILE" ]]; then
            read_manual_allocation "$cidr" "$domain_count"
        else
            echo "[ERROR] Manual mode requires IP_ALLOCATION_FILE"
            return 1
        fi
    fi
    
    echo $ips_per_domain
}
```

### Example: 8 Domains Sharing /24 with Configurable Limit
```
Configuration: MAX_IPS_PER_DOMAIN=30
Network: 6.6.6.0 (excluded)
Broadcast: 6.6.6.255 (excluded)
Usable: 254 IPs (6.6.6.1 - 6.6.6.254)
Calculation: 254 / 8 = 31.75
Applied limit: 30 IPs per domain
Total used: 240 IPs (30 * 8)
Unused: 14 IPs
```

## IP Allocations
```
domain1.net: 6.6.6.1   - 6.6.6.30   (30 IPs)
domain2.net: 6.6.6.31  - 6.6.6.60   (30 IPs)
domain3.net: 6.6.6.61  - 6.6.6.90   (30 IPs)
domain4.net: 6.6.6.91  - 6.6.6.120  (30 IPs)
domain5.net: 6.6.6.121 - 6.6.6.150  (30 IPs)
domain6.net: 6.6.6.151 - 6.6.6.180  (30 IPs)
domain7.net: 6.6.6.181 - 6.6.6.210  (30 IPs)
domain8.net: 6.6.6.211 - 6.6.6.240  (30 IPs)
priority.io: 10.10.10.1 - 10.10.10.30 (30 IPs)
```

## Enhanced Generator Input Creation
```bash
# Create input for enhanced generator with calculated ranges
generate_enhanced_input() {
    local output_file="enhanced_input.txt"
    > "$output_file"
    
    # Process each allocation
    echo "6.6.6.1/30,domain1.net" >> "$output_file"
    echo "6.6.6.31/30,domain2.net" >> "$output_file"
    echo "6.6.6.61/30,domain3.net" >> "$output_file"
    echo "6.6.6.91/30,domain4.net" >> "$output_file"
    echo "6.6.6.121/30,domain5.net" >> "$output_file"
    echo "6.6.6.151/30,domain6.net" >> "$output_file"
    echo "6.6.6.181/30,domain7.net" >> "$output_file"
    echo "6.6.6.211/30,domain8.net" >> "$output_file"
    echo "10.10.10.0/27,priority.io" >> "$output_file"
    
    echo "[INFO] Created enhanced generator input file with $(wc -l < "$output_file") entries"
}
```

## State Tracking
```json
{
  "timestamp": "2024-01-15T10:05:00Z",
  "distribution_config": {
    "mode": "even",
    "max_per_domain": 30,
    "shuffle_enabled": true
  },
  "ip_allocations": {
    "domain1.net": {
      "start": "6.6.6.1",
      "end": "6.6.6.30",
      "count": 30,
      "cidr": "6.6.6.0/24"
    },
    "domain2.net": {
      "start": "6.6.6.31",
      "end": "6.6.6.60",
      "count": 30,
      "cidr": "6.6.6.0/24"
    }
  },
  "summary": {
    "total_ips_allocated": 270,
    "total_domains": 9,
    "unused_ips": 14
  }
}
```

---

# Step 3: Generate Enhanced Hostnames and Mapping Files

## Run Enhanced Generator
```bash
# Execute enhanced generator with state tracking
./modules/enhanced_generator.sh enhanced_input.txt > hostnames.zone

# Check generation success
if [[ $? -eq 0 ]]; then
    echo "[SUCCESS] Generated $(wc -l < hostnames.zone) enhanced hostname records"
else
    echo "[ERROR] Enhanced hostname generation failed"
    exit 1
fi
```

## Sample Output (hostnames.zone) - ALL Enhanced, No Predictable Patterns
```
;; Enhanced A Record Generation Started: 2024-01-15T10:15:00Z
;; Input file: enhanced_input.txt

;; Block 6.6.6.0/24 (domains: domain1.net domain2.net domain3.net domain4.net domain5.net domain6.net domain7.net domain8.net)
;; Using randomized IP assignment and mixed naming styles
qh873a5f.domain1.net.    IN A 6.6.6.15
storm95kt.domain1.net.   IN A 6.6.6.3
h2o5-7fc.domain1.net.    IN A 6.6.6.28
nexu-142.domain1.net.    IN A 6.6.6.7
tw1842f3.domain2.net.    IN A 6.6.6.45
mesh127-89.domain2.net.  IN A 6.6.6.33
acgt-742.domain2.net.    IN A 6.6.6.58
node-8f3c4a.domain3.net. IN A 6.6.6.72
flux89-2a.domain3.net.   IN A 6.6.6.65
xe92-7h3.domain4.net.    IN A 6.6.6.102
t2024-8a3.domain4.net.   IN A 6.6.6.95
mx8-7291.domain5.net.    IN A 6.6.6.133
q7-spin4.domain5.net.    IN A 6.6.6.147
;; Generated 240 records for block 6.6.6.0/24

;; Block 10.10.10.0/27 (domains: priority.io)
;; Using randomized IP assignment and mixed naming styles
enc8x92m.priority.io.    IN A 10.10.10.15
tri8-2k4.priority.io.    IN A 10.10.10.3
c7-maj9.priority.io.     IN A 10.10.10.28
;; Generated 30 records for block 10.10.10.0/27

;; Generation completed: 2024-01-15T10:15:45Z
;; Total blocks processed: 2
;; Total unique names tracked: 270
```

## Parse Zone File to Create Line Files (CRITICAL STEP)
```bash
# Execute zone parser to create synchronized line files
./modules/zone_parser.sh hostnames.zone

# This creates the following synchronized files:
# - ip.txt (one IP per line)
# - hostname.txt (one enhanced hostname per line, same order as ip.txt)
# - domain.txt (extracted domain per line, same order)
# - third_octet.txt, fourth_octet.txt, last_digit_third.txt
# - domain_unique.txt (unique domains)

echo "[INFO] Zone parsing complete, created synchronized line files"
```

## Create Master Mapping File
```bash
# Generate comprehensive mapping JSON
generate_mapping_file() {
    local mapping_file="state/ip_hostname_mapping.json"
    
    echo "{" > "$mapping_file"
    echo '  "generated": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",' >> "$mapping_file"
    echo '  "total_ips": '$(wc -l < ip.txt)',' >> "$mapping_file"
    echo '  "mappings": [' >> "$mapping_file"
    
    # Process synchronized files
    paste -d'|' ip.txt hostname.txt domain.txt | while IFS='|' read ip hostname domain; do
        third=$(echo "$ip" | cut -d. -f3)
        fourth=$(echo "$ip" | cut -d. -f4)
        last_digit=$(echo "$third" | grep -o '.$')
        vmta_name="${domain}.c${last_digit}.${fourth}"
        hostname_short="${hostname%%.*}"
        
        cat >> "$mapping_file" <<EOF
    {
      "ip": "$ip",
      "hostname": "$hostname",
      "hostname_short": "$hostname_short",
      "domain": "$domain",
      "third_octet": "$third",
      "fourth_octet": "$fourth",
      "last_digit_third": "$last_digit",
      "vmta_name": "$vmta_name"
    },
EOF
    done
    
    # Fix last comma and close JSON
    sed -i '$ s/,$//' "$mapping_file"
    echo '  ]' >> "$mapping_file"
    echo '}' >> "$mapping_file"
    
    echo "[INFO] Created master mapping file: $mapping_file"
}
```

**ip_hostname_mapping.json:**
```json
{
  "generated": "2024-01-15T10:15:00Z",
  "total_ips": 270,
  "mappings": [
    {
      "ip": "6.6.6.15",
      "hostname": "qh873a5f.domain1.net",
      "hostname_short": "qh873a5f",
      "domain": "domain1.net",
      "third_octet": "6",
      "fourth_octet": "15",
      "last_digit_third": "6",
      "vmta_name": "domain1.net.c6.15"
    },
    {
      "ip": "6.6.6.3",
      "hostname": "storm95kt.domain1.net",
      "hostname_short": "storm95kt",
      "domain": "domain1.net",
      "third_octet": "6",
      "fourth_octet": "3",
      "last_digit_third": "6",
      "vmta_name": "domain1.net.c6.3"
    }
  ]
}
```

## Generate VMTA Mapping File
```json
{
  "domain1.net.c6.15": "qh873a5f.domain1.net",
  "domain1.net.c6.3": "storm95kt.domain1.net",
  "domain1.net.c6.28": "h2o5-7fc.domain1.net",
  "domain2.net.c6.45": "tw1842f3.domain2.net"
}
```

## Generated Ordered Files (Same Line Order - CRITICAL)

**ip.txt:**
```
6.6.6.15
6.6.6.3
6.6.6.28
6.6.6.7
6.6.6.45
6.6.6.33
6.6.6.58
6.6.6.72
```

**hostname.txt (ALL ENHANCED):**
```
qh873a5f.domain1.net
storm95kt.domain1.net
h2o5-7fc.domain1.net
nexu-142.domain1.net
tw1842f3.domain2.net
mesh127-89.domain2.net
acgt-742.domain2.net
node-8f3c4a.domain3.net
```

**domain.txt:**
```
domain1.net
domain1.net
domain1.net
domain1.net
domain2.net
domain2.net
domain2.net
domain3.net
```

**domain_unique.txt:**
```
domain1.net
domain2.net
domain3.net
domain4.net
domain5.net
domain6.net
domain7.net
domain8.net
priority.io
```

---

# Step 4: Generate PowerMTA Configurations

## Execute Module with Enhanced Hostnames
```bash
# Module reads configuration and uses enhanced hostnames exclusively
source config.sh
./modules/powermta_config.sh

echo "[INFO] PowerMTA configuration generation started"
echo "[INFO] Using port: $PMTA_PORT"
echo "[INFO] Pool prefix: $POOL_PREFIX"
echo "[INFO] All hostnames are enhanced (non-enumerable)"
```

## Generated Virtual-MTA Configuration (ALL ENHANCED)
```xml
<!-- ##################################### -->
<!-- domain1.net - ALL ENHANCED HOSTNAMES -->
<!-- ##################################### -->

<!-- SMTP Listeners -->
smtp-listener 6.6.6.15:10025
smtp-listener 6.6.6.3:10025
smtp-listener 6.6.6.28:10025
smtp-listener 6.6.6.7:10025

<!-- Virtual MTAs with Enhanced Hostnames Only -->
<virtual-mta domain1.net.c6.15>
smtp-source-host 6.6.6.15 qh873a5f.domain1.net
<domain *>
  max-msg-rate 5/m
</domain>
</virtual-mta>

<virtual-mta domain1.net.c6.3>
smtp-source-host 6.6.6.3 storm95kt.domain1.net
<domain *>
  max-msg-rate 5/m
</domain>
</virtual-mta>

<virtual-mta domain1.net.c6.28>
smtp-source-host 6.6.6.28 h2o5-7fc.domain1.net
<domain *>
  max-msg-rate 5/m
</domain>
</virtual-mta>

<virtual-mta domain1.net.c6.7>
smtp-source-host 6.6.6.7 nexu-142.domain1.net
<domain *>
  max-msg-rate 5/m
</domain>
</virtual-mta>

<!-- ##################################### -->
<!-- domain2.net - ALL ENHANCED HOSTNAMES -->
<!-- ##################################### -->

<virtual-mta domain2.net.c6.45>
smtp-source-host 6.6.6.45 tw1842f3.domain2.net
<domain *>
  max-msg-rate 5/m
</domain>
</virtual-mta>

<virtual-mta domain2.net.c6.33>
smtp-source-host 6.6.6.33 mesh127-89.domain2.net
<domain *>
  max-msg-rate 5/m
</domain>
</virtual-mta>
```

## New Pool Configuration (Configurable Naming Convention)
```xml
<!-- Pool configuration using template from config.sh -->
<virtual-mta-pool mailwizz_domain1_20240115.p>
virtual-mta domain1.net.c6.15
virtual-mta domain1.net.c6.3
virtual-mta domain1.net.c6.28
virtual-mta domain1.net.c6.7
virtual-mta domain1.net.c6.21
virtual-mta domain1.net.c6.14
<!-- ... all 30 IPs for domain1.net -->
</virtual-mta-pool>

<virtual-mta-pool mailwizz_domain2_20240115.p>
virtual-mta domain2.net.c6.45
virtual-mta domain2.net.c6.33
virtual-mta domain2.net.c6.58
virtual-mta domain2.net.c6.37
<!-- ... all 30 IPs for domain2.net -->
</virtual-mta-pool>

<virtual-mta-pool mailwizz_priority_20240115.p>
virtual-mta priority.io.c0.15
virtual-mta priority.io.c0.3
virtual-mta priority.io.c0.28
<!-- ... all 30 IPs for priority.io -->
</virtual-mta-pool>
```

## DKIM Configuration
```xml
<!-- Domain-key directives for DKIM signing -->
domain-key key1,domain1.net,/etc/pmta/domainkeys/key1_dkim.domain1.net.pem
domain-key key1,domain2.net,/etc/pmta/domainkeys/key1_dkim.domain2.net.pem
domain-key key1,domain3.net,/etc/pmta/domainkeys/key1_dkim.domain3.net.pem
```

## Backup and Apply
```bash
# Backup existing configuration
backup_pmta_config() {
    local timestamp=$(date +%s)
    local backup_file="$PMTA_CONFIG_PATH.backup.$timestamp"
    
    if [[ -f "$PMTA_CONFIG_PATH" ]]; then
        cp "$PMTA_CONFIG_PATH" "$backup_file"
        echo "[INFO] Backed up existing config to $backup_file"
        
        # Rotate old backups based on PMTA_BACKUP_RETAIN_DAYS
        find "$BACKUP_DIR" -name "config.backup.*" -mtime +$PMTA_BACKUP_RETAIN_DAYS -delete
    fi
}

# Validate new configuration
validate_pmta_config() {
    pmta --check generated_config.txt
    if [[ $? -eq 0 ]]; then
        echo "[SUCCESS] PowerMTA configuration is valid"
        return 0
    else
        echo "[ERROR] PowerMTA configuration validation failed"
        return 1
    fi
}

# Apply configuration
apply_pmta_config() {
    cat generated_config.txt >> "$PMTA_CONFIG_PATH"
    pmta reload
    echo "[SUCCESS] PowerMTA configuration applied and reloaded"
}
```

---

# Step 5: Generate DKIM Keys

## Generate Configurable Size Keys
```bash
#!/bin/bash
# Load configuration for key size and paths
source config.sh

echo "[INFO] Generating DKIM keys with size: $DKIM_KEY_SIZE bits"
echo "[INFO] Selector: $DKIM_SELECTOR"

# Create directories if they don't exist
mkdir -p "$DKIM_PRIVATE_PATH"
mkdir -p "$DKIM_PUBLIC_PATH"

# Backup existing keys if configured
if [[ "$DKIM_BACKUP_KEYS" == true ]]; then
    backup_dir="$BACKUP_DIR/dkim_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    if [[ -d "$DKIM_PRIVATE_PATH" ]] && ls "$DKIM_PRIVATE_PATH"/*.pem 1> /dev/null 2>&1; then
        cp "$DKIM_PRIVATE_PATH"/*.pem "$backup_dir/" 2>/dev/null
        echo "[INFO] Backed up existing DKIM keys to $backup_dir"
    fi
fi

# Generate keys for each unique domain
for domain in $(cat domain_unique.txt); do
    private_key="$DKIM_PRIVATE_PATH/${DKIM_SELECTOR}_dkim.${domain}.pem"
    public_key="$DKIM_PUBLIC_PATH/public_${DKIM_SELECTOR}_dkim.${domain}.pem"
    
    if [[ ! -f "$private_key" ]]; then
        # Generate private key
        openssl genrsa -out "$private_key" "$DKIM_KEY_SIZE"
        
        # Generate public key
        openssl rsa -in "$private_key" -pubout -out "$public_key"
        
        # Set permissions
        chmod 640 "$private_key"
        chown pmta:pmta "$private_key"
        chmod 644 "$public_key"
        
        echo "[SUCCESS] Generated ${DKIM_KEY_SIZE}-bit DKIM keys for ${domain}"
    else
        echo "[INFO] DKIM keys exist for ${domain}, skipping"
    fi
done
```

## Extract and Format Keys for Database
```bash
# Create JSON file for database import
create_dkim_json() {
    local json_file="dkim_keys.json"
    echo "[" > "$json_file"
    
    local first=true
    for domain in $(cat domain_unique.txt); do
        # Add comma if not first entry
        if [[ "$first" != true ]]; then
            echo "," >> "$json_file"
        fi
        first=false
        
        # Extract public key (remove headers and line breaks)
        public_key=$(cat "$DKIM_PUBLIC_PATH/public_${DKIM_SELECTOR}_dkim.${domain}.pem" | \
            grep -v "BEGIN\|END" | tr -d '\n')
        
        # Read private key with proper formatting
        private_key=$(cat "$DKIM_PRIVATE_PATH/${DKIM_SELECTOR}_dkim.${domain}.pem")
        
        # Create JSON entry
        cat >> "$json_file" <<EOF
  {
    "domain": "${domain}",
    "selector": "${DKIM_SELECTOR}",
    "private_key": "$(echo "$private_key" | sed ':a;N;$!ba;s/\n/\\n/g')",
    "public_key": "${public_key}",
    "key_size": ${DKIM_KEY_SIZE},
    "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
EOF
    done
    
    echo "" >> "$json_file"
    echo "]" >> "$json_file"
    
    echo "[SUCCESS] Created DKIM JSON export: $json_file"
}
```

## Store Keys in Database Format
```json
[
  {
    "domain": "domain1.net",
    "selector": "key1",
    "private_key": "-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEA75yHQfuVRf9S2...",
    "public_key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA75yHQfuVRf9S2...",
    "key_size": 2048,
    "generated_at": "2024-01-15T10:20:00Z"
  },
  {
    "domain": "domain2.net",
    "selector": "key1",
    "private_key": "-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEA8x3JK...",
    "public_key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8x3JK...",
    "key_size": 2048,
    "generated_at": "2024-01-15T10:20:01Z"
  }
]
```

---

# Step 6: Create DNS Records via Cloudflare

## Transform Zone File to updates.txt
```bash
#!/bin/bash
# Generate DNS updates file from enhanced hostnames

generate_dns_updates() {
    local updates_file="updates.txt"
    
    # Header
    echo "name    ttl    class    type    value    operation" > "$updates_file"
    
    # A Records from enhanced hostnames
    echo "[INFO] Processing A records from zone file"
    while read line; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$line" ]] && continue
        [[ ! "$line" =~ "IN A" ]] && continue
        
        hostname=$(echo "$line" | awk '{print $1}')
        ip=$(echo "$line" | awk '{print $5}')
        
        echo "${hostname}    ${DNS_TTL}    IN    A    ${ip}    create" >> "$updates_file"
    done < hostnames.zone
    
    echo "[INFO] Added $(grep -c "IN A" "$updates_file") A records"
}
```

## Generate updates.txt for Cloudflare Script

### A Records (ALL Enhanced Hostnames)
```
name    ttl    class    type    value    operation
qh873a5f.domain1.net.    300    IN    A    6.6.6.15    create
storm95kt.domain1.net.    300    IN    A    6.6.6.3    create
h2o5-7fc.domain1.net.    300    IN    A    6.6.6.28    create
nexu-142.domain1.net.    300    IN    A    6.6.6.7    create
tw1842f3.domain2.net.    300    IN    A    6.6.6.45    create
mesh127-89.domain2.net.    300    IN    A    6.6.6.33    create
acgt-742.domain2.net.    300    IN    A    6.6.6.58    create
node-8f3c4a.domain3.net.    300    IN    A    6.6.6.72    create
```

### DKIM TXT Records
```bash
# Add DKIM records to updates.txt
add_dkim_records() {
    for domain in $(cat domain_unique.txt); do
        public_key=$(jq -r --arg d "$domain" '.[] | select(.domain == $d) | .public_key' dkim_keys.json)
        
        echo "${DKIM_SELECTOR}._domainkey.${domain}.    ${DNS_TTL}    IN    TXT    \"v=DKIM1; k=rsa; p=${public_key}\"    create" >> updates.txt
    done
    
    echo "[INFO] Added $(grep -c "_domainkey" updates.txt) DKIM records"
}
```

### SPF Record Update
```bash
# Update SPF records with IP ranges
update_spf_records() {
    for domain in $(cat domain_unique.txt); do
        # Get existing SPF record
        existing_spf=$(dig +short TXT "$domain" | grep "v=spf1" || echo "")
        
        # Get IP range for this domain
        ip_range=$(grep "$domain" ip_allocations.json | jq -r '.range')
        
        if [[ -z "$existing_spf" ]]; then
            # Create new SPF record
            new_spf="v=spf1 ip4:${ip_range} ~all"
        else
            # Add to existing SPF if not present
            if [[ ! "$existing_spf" =~ "$ip_range" ]]; then
                # Insert IP range after v=spf1
                new_spf=$(echo "$existing_spf" | sed "s/v=spf1/v=spf1 ip4:${ip_range}/")
            else
                echo "[INFO] IP range already in SPF for $domain"
                continue
            fi
        fi
        
        echo "${domain}.    ${DNS_TTL}    IN    TXT    \"${new_spf}\"    update" >> updates.txt
    done
}
```

## Execute Cloudflare Update
```bash
# Run Cloudflare DNS management script
./modules/cloudflare_dns.sh --no-confirm

echo "[SUCCESS] DNS records created via Cloudflare API"
```

## Generate PTR Records File (Enhanced Hostnames)
```bash
# Generate PTR records for ISP submission
generate_ptr_records() {
    local ptr_file="ptr_records.txt"
    
    echo "; PTR Records for Enhanced Hostnames" > "$ptr_file"
    echo "; Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$ptr_file"
    echo "" >> "$ptr_file"
    
    paste -d'|' ip.txt hostname.txt | while IFS='|' read ip hostname; do
        # Reverse IP for PTR format
        reversed=$(echo "$ip" | awk -F. '{print $4"."$3"."$2"."$1}')
        echo "${reversed}.in-addr.arpa.    IN PTR ${hostname}." >> "$ptr_file"
    done
    
    echo "[INFO] Generated $(grep -c "IN PTR" "$ptr_file") PTR records"
}
```

### Sample PTR Records
```
15.6.6.6.in-addr.arpa.    IN PTR qh873a5f.domain1.net.
3.6.6.6.in-addr.arpa.     IN PTR storm95kt.domain1.net.
28.6.6.6.in-addr.arpa.    IN PTR h2o5-7fc.domain1.net.
7.6.6.6.in-addr.arpa.     IN PTR nexu-142.domain1.net.
45.6.6.6.in-addr.arpa.    IN PTR tw1842f3.domain2.net.
33.6.6.6.in-addr.arpa.    IN PTR mesh127-89.domain2.net.
```

---

# Step 7: Create Exim Virtual Mailboxes

## Create Mailboxes for Each Domain
```bash
#!/bin/bash
# Load configuration for mailbox settings
source config.sh

echo "[INFO] Creating mailboxes with prefixes: ${BOUNCE_PREFIX}@, ${FBL_PREFIX}@"
echo "[INFO] Mailbox path: ${MAILBOX_PATH}"

# Initialize password storage
> mailbox_passwords.csv
echo "domain,email,password,type" > mailbox_passwords.csv

for domain in $(cat domain_unique.txt); do
    echo "[INFO] Creating mailboxes for ${domain}"
    
    # Generate secure passwords
    bounce_pass=$(openssl rand -base64 16)
    fbl_pass=$(openssl rand -base64 16)
    
    # Create virtual domain directory structure
    mkdir -p "/etc/exim/virtual/${domain}"
    
    # Create passwd file for Exim
    passwd_file="/etc/exim/virtual/${domain}/passwd"
    
    # Add bounce mailbox
    echo "${BOUNCE_PREFIX}:$(openssl passwd -1 ${bounce_pass}):1001:1001::${MAILBOX_PATH}/${domain}/bounce::" \
        > "$passwd_file"
    
    # Add FBL mailbox
    echo "${FBL_PREFIX}:$(openssl passwd -1 ${fbl_pass}):1001:1001::${MAILBOX_PATH}/${domain}/fbl::" \
        >> "$passwd_file"
    
    # Create Maildir structures
    for mailbox in bounce fbl; do
        maildir="${MAILBOX_PATH}/${domain}/${mailbox}"
        mkdir -p "${maildir}"/{cur,new,tmp}
        
        # Set ownership and permissions
        chown -R ${DOVECOT_USER}:${DOVECOT_GROUP} "${maildir}"
        chmod 700 "${maildir}"
        chmod 700 "${maildir}"/{cur,new,tmp}
    done
    
    # Store passwords for database import
    echo "${domain},${BOUNCE_PREFIX}@${domain},${bounce_pass},bounce" >> mailbox_passwords.csv
    echo "${domain},${FBL_PREFIX}@${domain},${fbl_pass},fbl" >> mailbox_passwords.csv
    
    echo "[SUCCESS] Created mailboxes for ${domain}"
done

echo "[INFO] Total mailboxes created: $(( $(cat domain_unique.txt | wc -l) * 2 ))"
```

## Dovecot Configuration Update
```bash
# Update Dovecot users file
update_dovecot_users() {
    local dovecot_users="/etc/dovecot/users"
    
    # Backup existing users file
    if [[ -f "$dovecot_users" ]]; then
        cp "$dovecot_users" "${dovecot_users}.backup.$(date +%s)"
    fi
    
    # Add new mailbox users
    while IFS=',' read -r domain email password type; do
        [[ "$email" == "email" ]] && continue  # Skip header
        
        # Generate encrypted password for Dovecot
        encrypted=$(openssl passwd -1 "$password")
        
        # Add to Dovecot users
        echo "${email}:{CRYPT}${encrypted}:1001:1001::${MAILBOX_PATH}/${domain}/${type}" >> "$dovecot_users"
    done < mailbox_passwords.csv
    
    # Reload Dovecot
    systemctl reload dovecot
    echo "[SUCCESS] Dovecot configuration updated"
}
```

### Sample Dovecot Users File
```
# /etc/dovecot/users
bounce@domain1.net:{CRYPT}$1$xyz12345$aB3dE5fG7hI9jK1L:1001:1001::/var/mail/virtual/domain1.net/bounce
fbl@domain1.net:{CRYPT}$1$abc67890$mN4oP6qR8sT0uV2W:1001:1001::/var/mail/virtual/domain1.net/fbl
bounce@domain2.net:{CRYPT}$1$def13579$xY3zA5bC7dE9fG1H:1001:1001::/var/mail/virtual/domain2.net/bounce
fbl@domain2.net:{CRYPT}$1$ghi24680$iJ3kL5mN7oP9qR1S:1001:1001::/var/mail/virtual/domain2.net/fbl
```

## Test IMAP Access
```bash
# Test mailbox access
test_mailbox_access() {
    echo "[INFO] Testing IMAP access for all mailboxes"
    
    while IFS=',' read -r domain email password type; do
        [[ "$email" == "email" ]] && continue  # Skip header
        
        echo -n "Testing ${email}... "
        
        if doveadm auth test "$email" "$password" &>/dev/null; then
            echo "SUCCESS"
        else
            echo "FAILED"
            echo "[ERROR] Authentication failed for ${email}" >&2
        fi
    done < mailbox_passwords.csv
}
```

---

# Step 8: Sync to MailWizz Database

## Database Operations (Order Critical for Foreign Keys)

### 1. Create Tracking Domains
```sql
-- Create tracking domains for each unique domain
INSERT INTO mw_tracking_domain (name, scheme, date_added, last_updated) VALUES 
('track.domain1.net', 'https', NOW(), NOW()),
('track.domain2.net', 'https', NOW(), NOW()),
('track.domain3.net', 'https', NOW(), NOW()),
('track.domain4.net', 'https', NOW(), NOW()),
('track.domain5.net', 'https', NOW(), NOW()),
('track.domain6.net', 'https', NOW(), NOW()),
('track.domain7.net', 'https', NOW(), NOW()),
('track.domain8.net', 'https', NOW(), NOW()),
('track.priority.io', 'https', NOW(), NOW());
```

### 2. Create Bounce Servers
```sql
-- Create bounce servers from mailbox configuration
INSERT INTO mw_bounce_server (
    name, hostname, username, password, service, port,
    protocol, validate_ssl, locked, status, date_added, last_updated
) VALUES 
('Bounce-domain1.net', 'localhost', 'bounce@domain1.net', 'encrypted_pass_here', 'imap', 143,
 'imap-novalidate-cert', 'no', 'no', 'active', NOW(), NOW()),
('Bounce-domain2.net', 'localhost', 'bounce@domain2.net', 'encrypted_pass_here', 'imap', 143,
 'imap-novalidate-cert', 'no', 'no', 'active', NOW(), NOW()),
('Bounce-domain3.net', 'localhost', 'bounce@domain3.net', 'encrypted_pass_here', 'imap', 143,
 'imap-novalidate-cert', 'no', 'no', 'active', NOW(), NOW()),
-- Continue for all domains
```

### 3. Create FBL Servers
```sql
-- Create FBL servers from mailbox configuration
INSERT INTO mw_feedback_loop_server (
    name, hostname, username, password, service, port,
    protocol, validate_ssl, locked, status, date_added, last_updated
) VALUES 
('FBL-domain1.net', 'localhost', 'fbl@domain1.net', 'encrypted_pass_here', 'imap', 143,
 'imap-novalidate-cert', 'no', 'no', 'active', NOW(), NOW()),
('FBL-domain2.net', 'localhost', 'fbl@domain2.net', 'encrypted_pass_here', 'imap', 143,
 'imap-novalidate-cert', 'no', 'no', 'active', NOW(), NOW()),
-- Continue for all domains
```

### 4. Create Sending Domains with DKIM
```sql
-- Import DKIM keys from JSON file
-- Using data from dkim_keys.json
INSERT INTO mw_sending_domain (
    name, dkim_private_key, dkim_public_key,
    signing_enabled, verified, locked, date_added, last_updated
) VALUES 
('domain1.net', '-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEA75yHQ...', 'MIIBIjANBgkqhkiG9w0BAQE...',
 'yes', 'yes', 'no', NOW(), NOW()),
('domain2.net', '-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEA8x3JK...', 'MIIBIjANBgkqhkiG9w0BAQE...',
 'yes', 'yes', 'no', NOW(), NOW()),
-- Continue for all domains
```

### 5. Create Enhanced Hostname Mapping Table
```sql
-- Create custom table for tracking enhanced hostname mappings
CREATE TABLE IF NOT EXISTS mw_enhanced_hostnames (
    id INT AUTO_INCREMENT PRIMARY KEY,
    ip_address VARCHAR(45) NOT NULL UNIQUE,
    enhanced_hostname VARCHAR(255) NOT NULL,
    domain VARCHAR(255) NOT NULL,
    vmta_name VARCHAR(255) NOT NULL,
    pool_name VARCHAR(255),
    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_ip (ip_address),
    INDEX idx_hostname (enhanced_hostname),
    INDEX idx_vmta (vmta_name),
    INDEX idx_pool (pool_name),
    INDEX idx_domain (domain)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- Import from ip_hostname_mapping.json
INSERT INTO mw_enhanced_hostnames (ip_address, enhanced_hostname, domain, vmta_name, pool_name) VALUES
('6.6.6.15', 'qh873a5f.domain1.net', 'domain1.net', 'domain1.net.c6.15', 'mailwizz_domain1_20240115'),
('6.6.6.3', 'storm95kt.domain1.net', 'domain1.net', 'domain1.net.c6.3', 'mailwizz_domain1_20240115'),
('6.6.6.28', 'h2o5-7fc.domain1.net', 'domain1.net', 'domain1.net.c6.28', 'mailwizz_domain1_20240115'),
('6.6.6.7', 'nexu-142.domain1.net', 'domain1.net', 'domain1.net.c6.7', 'mailwizz_domain1_20240115'),
('6.6.6.45', 'tw1842f3.domain2.net', 'domain2.net', 'domain2.net.c6.45', 'mailwizz_domain2_20240115'),
('6.6.6.33', 'mesh127-89.domain2.net', 'domain2.net', 'domain2.net.c6.33', 'mailwizz_domain2_20240115'),
-- Continue for all 270 IPs
```

### 6. Create Delivery Servers with Configuration
```sql
-- Create delivery servers using configuration values
-- Each IP gets its own delivery server entry
INSERT INTO mw_delivery_server (
    type, name, hostname, username, password, port,
    protocol, timeout, from_email, from_name,
    bounce_server_id, tracking_domain_id, status,
    hourly_quota, daily_quota, monthly_quota,
    pause_after_send, locked, use_for, signing_enabled,
    customer_id, warmup_plan_id, date_added, last_updated
) VALUES 
-- Example for domain1.net IPs
('smtp-pmta', 'PMTA-6-6-6-15', '6.6.6.15', '', '', 10025,
 '', 30, 'noreply@domain1.net', 'Domain1',
 1, 1, 'active', 1000, 10000, 0,
 0, 'no', 'all', 'yes', NULL, NULL, NOW(), NOW()),
 
('smtp-pmta', 'PMTA-6-6-6-3', '6.6.6.3', '', '', 10025,
 '', 30, 'noreply@domain1.net', 'Domain1',
 1, 1, 'active', 1000, 10000, 0,
 0, 'no', 'all', 'yes', NULL, NULL, NOW(), NOW()),
 
('smtp-pmta', 'PMTA-6-6-6-28', '6.6.6.28', '', '', 10025,
 '', 30, 'noreply@domain1.net', 'Domain1',
 1, 1, 'active', 1000, 10000, 0,
 0, 'no', 'all', 'yes', NULL, NULL, NOW(), NOW()),
 
-- Example for domain2.net IPs
('smtp-pmta', 'PMTA-6-6-6-45', '6.6.6.45', '', '', 10025,
 '', 30, 'noreply@domain2.net', 'Domain2',
 2, 2, 'active', 1000, 10000, 0,
 0, 'no', 'all', 'yes', NULL, NULL, NOW(), NOW()),
-- Continue for all 270 IPs
```

## Transaction Management
```sql
-- Use transactions for atomicity
START TRANSACTION;

-- All INSERT statements here
-- ...

-- Check for errors
-- If any error: ROLLBACK;
-- If all success: COMMIT;

COMMIT;
```

## Bash Script for Database Sync
```bash
#!/bin/bash
# mailwizz_db.sh - Sync to MailWizz database

source config.sh

# Database connection
mysql_cmd="mysql -h $DB_HOST -u $DB_USER -p$DB_PASS $DB_NAME"

# Start transaction
echo "START TRANSACTION;" > sync.sql

# Generate SQL statements
generate_tracking_domains >> sync.sql
generate_bounce_servers >> sync.sql
generate_fbl_servers >> sync.sql
generate_sending_domains >> sync.sql
generate_enhanced_mapping >> sync.sql
generate_delivery_servers >> sync.sql

# Commit transaction
echo "COMMIT;" >> sync.sql

# Execute SQL
$mysql_cmd < sync.sql

if [[ $? -eq 0 ]]; then
    echo "[SUCCESS] Database sync completed"
else
    echo "[ERROR] Database sync failed"
    exit 1
fi
```

---

# Step 9: Complete Validation

## DNS Validation (Enhanced Hostnames)
```bash
#!/bin/bash
# Validate DNS records

validate_dns_records() {
    echo "[INFO] Starting DNS validation"
    local errors=0
    
    # Test A records with enhanced hostnames
    while IFS='|' read -r ip hostname; do
        resolved_ip=$(dig +short "$hostname" 2>/dev/null)
        
        if [[ "$resolved_ip" == "$ip" ]]; then
            echo "[SUCCESS] $hostname â†’ $ip"
        else
            echo "[ERROR] $hostname failed (expected: $ip, got: $resolved_ip)"
            ((errors++))
        fi
    done < <(paste -d'|' ip.txt hostname.txt)
    
    # Test DKIM records
    for domain in $(cat domain_unique.txt); do
        dkim_record=$(dig +short TXT "${DKIM_SELECTOR}._domainkey.${domain}" 2>/dev/null)
        
        if [[ -n "$dkim_record" ]]; then
            echo "[SUCCESS] DKIM record found for $domain"
        else
            echo "[ERROR] DKIM record missing for $domain"
            ((errors++))
        fi
    done
    
    # Test SPF records
    for domain in $(cat domain_unique.txt); do
        spf_record=$(dig +short TXT "$domain" | grep "v=spf1")
        
        if [[ -n "$spf_record" ]]; then
            echo "[SUCCESS] SPF record found for $domain"
        else
            echo "[ERROR] SPF record missing for $domain"
            ((errors++))
        fi
    done
    
    # Test PTR records
    sample_ips=($(head -5 ip.txt))
    for ip in "${sample_ips[@]}"; do
        ptr=$(dig +short -x "$ip" 2>/dev/null)
        
        if [[ -n "$ptr" ]]; then
            echo "[SUCCESS] PTR record found for $ip: $ptr"
        else
            echo "[WARNING] PTR record not found for $ip (may need ISP configuration)"
        fi
    done
    
    if [[ $errors -eq 0 ]]; then
        echo "[SUCCESS] All DNS validations passed"
        return 0
    else
        echo "[ERROR] DNS validation failed with $errors errors"
        return 1
    fi
}
```

## PowerMTA Validation
```bash
# Validate PowerMTA configuration
validate_powermta() {
    echo "[INFO] Starting PowerMTA validation"
    
    # Test connections
    sample_ips=($(head -5 ip.txt))
    for ip in "${sample_ips[@]}"; do
        if timeout 2 telnet "$ip" "$PMTA_PORT" 2>&1 | grep -q "Connected"; then
            echo "[SUCCESS] PowerMTA listening on $ip:$PMTA_PORT"
        else
            echo "[ERROR] PowerMTA not responding on $ip:$PMTA_PORT"
        fi
    done
    
    # Check virtual-mta with enhanced hostnames
    vmta_sample="domain1.net.c6.15"
    if pmta show vmta "$vmta_sample" 2>&1 | grep -q "qh873a5f.domain1.net"; then
        echo "[SUCCESS] VMTA $vmta_sample using enhanced hostname"
    else
        echo "[ERROR] VMTA $vmta_sample not configured correctly"
    fi
    
    # Check pool configuration
    pool_sample="mailwizz_domain1_20240115"
    if pmta show pool "$pool_sample" 2>&1 | grep -q "domain1.net.c"; then
        echo "[SUCCESS] Pool $pool_sample configured"
    else
        echo "[ERROR] Pool $pool_sample not found"
    fi
}
```

## Mailbox Validation
```bash
# Validate mailbox creation
validate_mailboxes() {
    echo "[INFO] Starting mailbox validation"
    local errors=0
    
    # Test IMAP for each domain
    for domain in $(cat domain_unique.txt); do
        echo "Testing mailboxes for $domain..."
        
        # Get password from CSV
        bounce_pass=$(grep "bounce@${domain}" mailbox_passwords.csv | cut -d',' -f3)
        fbl_pass=$(grep "fbl@${domain}" mailbox_passwords.csv | cut -d',' -f3)
        
        # Test bounce mailbox
        if doveadm auth test "bounce@${domain}" "$bounce_pass" &>/dev/null; then
            echo "[SUCCESS] bounce@${domain} authenticated"
        else
            echo "[ERROR] bounce@${domain} authentication failed"
            ((errors++))
        fi
        
        # Test FBL mailbox
        if doveadm auth test "fbl@${domain}" "$fbl_pass" &>/dev/null; then
            echo "[SUCCESS] fbl@${domain} authenticated"
        else
            echo "[ERROR] fbl@${domain} authentication failed"
            ((errors++))
        fi
    done
    
    if [[ $errors -eq 0 ]]; then
        echo "[SUCCESS] All mailbox validations passed"
        return 0
    else
        echo "[ERROR] Mailbox validation failed with $errors errors"
        return 1
    fi
}
```

## Database Validation
```sql
-- Check delivery servers
SELECT COUNT(*) as total_servers FROM mw_delivery_server WHERE hostname LIKE '6.6.6.%' OR hostname LIKE '10.10.10.%';
-- Expected: 270 (total IPs configured)

-- Check enhanced hostname mappings
SELECT 
    ip_address, 
    enhanced_hostname, 
    vmta_name, 
    pool_name 
FROM mw_enhanced_hostnames 
WHERE domain = 'domain1.net' 
LIMIT 5;
-- Expected: All enhanced hostnames, no predictable patterns

-- Verify relationships
SELECT 
    ds.name as server_name,
    ds.hostname as ip,
    eh.enhanced_hostname,
    bs.name as bounce_server,
    td.name as tracking_domain
FROM mw_delivery_server ds
LEFT JOIN mw_enhanced_hostnames eh ON ds.hostname = eh.ip_address
JOIN mw_bounce_server bs ON ds.bounce_server_id = bs.server_id
JOIN mw_tracking_domain td ON ds.tracking_domain_id = td.domain_id
WHERE ds.hostname = '6.6.6.15';
-- Expected: Complete record with enhanced hostname

-- Check sending domains with DKIM
SELECT 
    name as domain,
    LENGTH(dkim_private_key) as private_key_length,
    LENGTH(dkim_public_key) as public_key_length,
    signing_enabled,
    verified
FROM mw_sending_domain
ORDER BY name;
-- Expected: All domains with keys, signing enabled
```

## MailWizz UI Validation
1. Login to MailWizz admin panel
2. Navigate to Backend â†’ Misc â†’ Delivery servers
3. Search for "PMTA-6-6-6-15"
4. Click "Validate server" button
5. Expected: "SUCCESS! Connection was successful!"
6. Check that FROM address shows correct domain
7. Verify bounce server is assigned
8. Verify tracking domain is assigned

## End-to-End Email Test

### âœ… CORRECT: Headers with Enhanced Hostnames Only
```bash
# Send test email through MailWizz
# Examine full headers

Received: from qh873a5f.domain1.net (qh873a5f.domain1.net [6.6.6.15])
    by mx.recipient.com (Postfix) with ESMTP id 4N8K2M3xQzZ
    for <test@recipient.com>; Wed, 15 Jan 2024 10:30:00 +0000
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
    d=domain1.net; s=key1;
    h=from:to:subject:date:message-id;
    bh=xyz123...;
    b=abc456...
Return-Path: bounce@domain1.net
X-PowerMTA-VirtualMTA: domain1.net.c6.15
SPF: PASS (6.6.6.15 included in ip4:6.6.6.0/24)
```

### âŒ WRONG: Signs of Misconfiguration
```bash
# BAD: ANY predictable hostname patterns
Received: from mail1.domain1.net           # Sequential numbering!
Received: from smtp6.domain1.net           # Enumerable!
Received: from mailer6-vmta-6-15.domain1.net  # Exposes infrastructure!
Received: from mta-6-6-6-15.domain1.net    # IP in hostname!

# BAD: Missing DKIM signature
DKIM-Signature: [MISSING]  # Key not configured

# BAD: Wrong Return-Path
Return-Path: admin@domain1.net  # Should be bounce@domain1.net
Return-Path: noreply@domain1.net  # Should be bounce@domain1.net

# BAD: SPF failure
Received-SPF: fail (6.6.6.15 not included)  # IP range not in SPF

# BAD: Port mismatch
telnet: connect to address 6.6.6.15: Connection refused  # PowerMTA not listening

# BAD: No enhanced hostname mapping
SELECT enhanced_hostname FROM mw_enhanced_hostnames WHERE ip_address = '6.6.6.15';
-- Returns NULL or predictable pattern
```

## Common Pitfalls Summary

### Architecture Mistakes to Avoid
1. **Using ANY predictable hostnames** - All must be enhanced throughout
2. **Hardcoding limits** - Use config.sh for all settings
3. **Missing state files** - Each module needs state tracking
4. **Wrong operation order** - Follow foreign key requirements
5. **Incomplete validation** - Test all components
6. **Missing mailboxes** - Both bounce@ and fbl@ required
7. **Incorrect pool naming** - Use configured template
8. **Sequential IP assignment** - Must be randomized

### Configuration Mistakes to Avoid
1. **MAX_IPS_PER_DOMAIN too high** - Check CIDR block limits
2. **Wrong DKIM_KEY_SIZE** - Some providers require 2048-bit minimum
3. **Missing DB_PASS** - Set via environment variable for security
4. **Wrong paths** - Verify PMTA and mailbox paths exist
5. **Incorrect ownership** - pmta:pmta for DKIM, vmail:vmail for mailboxes

### Why This Project Matters
- **Security**: Complete non-enumerable infrastructure
- **Configurability**: Central config.sh for all settings
- **Scale**: Handles 10,000+ IPs efficiently
- **Automation**: 8 hours manual â†’ 5 minutes automated
- **Compliance**: Full audit trail and rollback capability
- **Reliability**: State management enables recovery

---

## State Management Files

### state/processed.json
```json
{
  "last_run": "2024-01-15T10:30:00Z",
  "script_version": "1.0.0",
  "config_used": {
    "max_ips_per_domain": 30,
    "distribution_mode": "even",
    "pool_prefix": "mailwizz",
    "dkim_key_size": 2048,
    "config_hash": "a3f2b8c9d4e5f6789abc"
  },
  "processed_ranges": [
    {
      "range": "6.6.6.0/24",
      "domains": ["domain1.net", "domain2.net", "domain3.net", "domain4.net", 
                  "domain5.net", "domain6.net", "domain7.net", "domain8.net"],
      "ips_allocated": 240,
      "status": "complete"
    },
    {
      "range": "10.10.10.0/27",
      "domains": ["priority.io"],
      "ips_allocated": 30,
      "status": "complete"
    }
  ],
  "totals": {
    "domains_processed": 9,
    "ips_configured": 270,
    "enhanced_hostnames_generated": 270,
    "mailboxes_created": 18,
    "dns_records_created": 549
  }
}
```

### state/ip_hostname_mapping.json
Contains complete IP to enhanced hostname mappings for all 270 IPs with vmta names and pool assignments.

### state/vmta_mapping.json
Maps vmta names to enhanced hostnames for PowerMTA reference.

### state/pool_mapping.json
```json
{
  "mailwizz_domain1_20240115": {
    "domain": "domain1.net",
    "vmtas": ["domain1.net.c6.15", "domain1.net.c6.3", "..."],
    "ip_count": 30,
    "created": "2024-01-15T10:25:00Z"
  },
  "mailwizz_domain2_20240115": {
    "domain": "domain2.net",
    "vmtas": ["domain2.net.c6.45", "domain2.net.c6.33", "..."],
    "ip_count": 30,
    "created": "2024-01-15T10:25:01Z"
  }
}
```

### logs/2024-01-15_103000.log
```
[2024-01-15 10:30:00] [INFO] Starting mailwizz--inventory_manager.sh
[2024-01-15 10:30:01] [INFO] Configuration loaded from config.sh
[2024-01-15 10:30:01] [INFO] MAX_IPS_PER_DOMAIN: 30
[2024-01-15 10:30:01] [INFO] IP_DISTRIBUTION_MODE: even
[2024-01-15 10:30:01] [INFO] POOL_PREFIX: mailwizz
[2024-01-15 10:30:01] [INFO] DKIM_KEY_SIZE: 2048
[2024-01-15 10:30:02] [INFO] Processing 9 domains from new.csv
[2024-01-15 10:30:02] [INFO] 8 domains sharing 6.6.6.0/24
[2024-01-15 10:30:02] [INFO] 1 domain with 10.10.10.0/27
[2024-01-15 10:30:03] [INFO] Calculating IP distribution with limit of 30 per domain
[2024-01-15 10:30:05] [INFO] Running enhanced generator for 270 IPs
[2024-01-15 10:30:15] [INFO] Generated 270 enhanced hostnames (all non-enumerable)
[2024-01-15 10:30:16] [INFO] Zone file parsed to synchronized line files
[2024-01-15 10:30:20] [INFO] Created 270 PowerMTA configurations with enhanced hostnames
[2024-01-15 10:30:22] [INFO] Generated 9 DKIM key pairs (2048-bit)
[2024-01-15 10:30:25] [INFO] Created 540 DNS records (270 A + 270 PTR)
[2024-01-15 10:30:26] [INFO] Updated 9 SPF records
[2024-01-15 10:30:28] [INFO] Created 18 mailboxes (9 bounce + 9 FBL)
[2024-01-15 10:30:35] [INFO] Inserted 270 delivery servers in database
[2024-01-15 10:30:36] [INFO] Created enhanced hostname mapping table
[2024-01-15 10:30:40] [INFO] All validations passed
[2024-01-15 10:30:40] [INFO] Process complete: 270 IPs configured with enhanced hostnames
```

---

## Module Structure
```
mailwizz--inventory_manager.sh      # Main orchestration script
â”œâ”€â”€ config.sh                        # Master configuration file
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ enhanced_generator.sh       # Generate unique hostnames (existing)
â”‚   â”œâ”€â”€ zone_parser.sh              # Parse zone to line files (new)
â”‚   â”œâ”€â”€ powermta_config.sh          # Create PMTA configs (modified)
â”‚   â”œâ”€â”€ dkim_generator.sh           # Generate configurable keys (modified)
â”‚   â”œâ”€â”€ generate_dns_updates.sh     # Create updates.txt (new)
â”‚   â”œâ”€â”€ cloudflare_dns.sh          # Manage DNS records (existing)
â”‚   â”œâ”€â”€ exim_mailbox.sh            # Create mailboxes (new)
â”‚   â”œâ”€â”€ mailwizz_db.sh             # Database operations (new)
â”‚   â””â”€â”€ state_wrapper.sh           # State management wrapper (new)
â”œâ”€â”€ state/
â”‚   â”œâ”€â”€ processed.json              # Overall process state
â”‚   â”œâ”€â”€ ip_hostname_mapping.json    # Complete IP mappings
â”‚   â”œâ”€â”€ vmta_mapping.json          # VMTA to hostname map
â”‚   â”œâ”€â”€ pool_mapping.json          # Pool configurations
â”‚   â”œâ”€â”€ used_names.json            # Enhanced generator state
â”‚   â”œâ”€â”€ powermta.json              # PowerMTA module state
â”‚   â”œâ”€â”€ dns.json                   # DNS module state
â”‚   â”œâ”€â”€ database.json              # Database module state
â”‚   â””â”€â”€ mailboxes.json             # Mailbox module state
â”œâ”€â”€ logs/
â”‚   â””â”€â”€ 2024-01-15_103000.log      # Process log
â”œâ”€â”€ reports/
â”‚   â””â”€â”€ validation_report.txt       # Validation results
â””â”€â”€ backups/
    â”œâ”€â”€ config_backup_1705316400/   # Configuration backups
    â”œâ”€â”€ dkim_backup_1705316400/     # DKIM key backups
    â””â”€â”€ database_backup_1705316400.sql  # Database backup
