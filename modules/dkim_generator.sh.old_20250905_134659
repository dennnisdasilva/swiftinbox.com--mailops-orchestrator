#!/bin/bash

# DKIM Generator Module DKIM Integration Module
# Purpose: Generate 2048-bit DKIM keys for domains from new.csv
# Fixes: Proper CSV parsing, header skipping, CIDR handling
# Date: September 5, 2025

set -euo pipefail

# Configuration
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
DEBUG="${DEBUG:-false}"

# Paths
INPUT_CSV="$PROJECT_ROOT/input/new.csv"
OUTPUT_DIR="$PROJECT_ROOT/output"
KEYS_DIR="$OUTPUT_DIR/keys"
PUBLIC_KEYS_DIR="$KEYS_DIR/public"
DKIM_TRACKING="$OUTPUT_DIR/dkim_data.json"
PMTA_KEYS_DIR="/etc/pmta/domainkeys"
EXISTING_DKIM_SCRIPT="$PROJECT_ROOT/existing_scripts/powermta--generate_dkim_add_to_configs.sh"

# DKIM Configuration
KEY_SIZE=2048
SELECTOR="key1"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure logs directory exists
[[ ! -d "$PROJECT_ROOT/logs" ]] && mkdir -p "$PROJECT_ROOT/logs"
LOG_FILE="$PROJECT_ROOT/logs/dkim_integration_${TIMESTAMP}.log"
DEBUG_LOG="$PROJECT_ROOT/logs/dkim_debug_${TIMESTAMP}.log"

# Logging functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $1" >> "$LOG_FILE"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] WARN: $1" >> "$LOG_FILE"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1" >> "$LOG_FILE"
}

log_debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] DEBUG: $1" >> "$DEBUG_LOG"
    fi
}

# Change to project root
cd "$PROJECT_ROOT"

echo "========================================="
echo "DKIM Integration Module (Fixed)"
echo "========================================="
echo "Project Root: $PROJECT_ROOT"
echo "Timestamp: $TIMESTAMP"
echo "Debug Mode: $DEBUG"
echo "Key Size: $KEY_SIZE bits"
echo "Selector: $SELECTOR"
echo "Log File: $LOG_FILE"
[[ "$DEBUG" == "true" ]] && echo "Debug Log: $DEBUG_LOG"
echo "========================================="

# Log startup
log_info "DKIM Integration (Fixed) started at $TIMESTAMP"
log_debug "Environment: $(env | grep -E '^(PATH|USER|PWD)' | tr '\n' ' ')"

# Verify prerequisites
log_info "Verifying prerequisites..."

if ! command -v openssl &> /dev/null; then
    log_error "OpenSSL is not installed or not in PATH"
    exit 1
fi
log_debug "OpenSSL version: $(openssl version)"

if [[ ! -f "$INPUT_CSV" ]]; then
    log_error "Input CSV not found at: $INPUT_CSV"
    exit 1
fi
log_debug "Input CSV exists with $(wc -l < "$INPUT_CSV") lines"

# Step 1: Create backup if running for first time today
backup_marker="$PROJECT_ROOT/backups/.dkim_backup_$(date +%Y%m%d)"
if [[ ! -f "$backup_marker" ]] && [[ -f "$EXISTING_DKIM_SCRIPT" ]]; then
    log_info "Creating daily backup of existing DKIM script..."
    backup_path="$PROJECT_ROOT/backups/powermta--generate_dkim_${TIMESTAMP}.sh"
    cp "$EXISTING_DKIM_SCRIPT" "$backup_path"
    touch "$backup_marker"
    log_debug "Backed up to: $backup_path"
else
    log_debug "Daily backup already exists or no script to backup"
fi

# Step 2: Create necessary directories
log_info "Creating directory structure..."
directories=(
    "$KEYS_DIR"
    "$PUBLIC_KEYS_DIR"
    "$KEYS_DIR/private"
    "$KEYS_DIR/dns_records"
)

for dir in "${directories[@]}"; do
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        log_debug "Created directory: $dir"
    else
        log_debug "Directory exists: $dir"
    fi
done

# Check if PowerMTA directories exist, create if needed
log_debug "Checking PowerMTA directory: $PMTA_KEYS_DIR"
if [[ ! -d "$PMTA_KEYS_DIR" ]]; then
    log_warn "PowerMTA keys directory doesn't exist, attempting to create..."
    
    if sudo mkdir -p "$PMTA_KEYS_DIR" 2>/dev/null; then
        log_info "Created $PMTA_KEYS_DIR"
        sudo chmod 755 "$PMTA_KEYS_DIR"
    else
        log_error "Failed to create $PMTA_KEYS_DIR - continuing with local storage only"
        PMTA_KEYS_DIR=""
    fi
else
    log_debug "PowerMTA directory exists"
    # Check permissions
    if [[ -w "$PMTA_KEYS_DIR" ]] || sudo test -w "$PMTA_KEYS_DIR" 2>/dev/null; then
        log_debug "PowerMTA directory is writable"
    else
        log_warn "PowerMTA directory may not be writable"
    fi
fi

# Check if pmta user exists
log_debug "Checking for pmta user..."
if id "pmta" &>/dev/null; then
    log_debug "User 'pmta' exists with UID: $(id -u pmta)"
    SKIP_CHOWN=false
else
    log_warn "User 'pmta' does not exist - ownership changes will be skipped"
    SKIP_CHOWN=true
fi

# Step 3: Extract unique domains from new.csv (FIXED PARSING)
log_info "Extracting domains from new.csv..."

declare -A unique_domains
domain_count=0
line_num=0
header_detected=false

log_debug "Starting CSV parsing..."

# Read the CSV file
while IFS=',' read -r col1 col2 rest; do
    line_num=$((line_num + 1))
    
    # Skip empty lines
    if [[ -z "$col1" ]]; then
        log_debug "Line $line_num: Skipping empty line"
        continue
    fi
    
    # Skip comments
    if [[ "$col1" =~ ^#.*$ ]]; then
        log_debug "Line $line_num: Skipping comment line"
        continue
    fi
    
    # Detect and skip header row
    if [[ "$col1" == "action" ]] || [[ "$col2" == "ip_range" ]]; then
        log_debug "Line $line_num: Detected header row, skipping"
        header_detected=true
        continue
    fi
    
    # Also skip if first line looks like a header (contains text like "domain1", "domain2")
    if [[ $line_num -eq 1 ]] && [[ "$rest" =~ domain[0-9] ]]; then
        log_debug "Line $line_num: Detected header pattern, skipping"
        header_detected=true
        continue
    fi
    
    log_debug "Line $line_num: Processing - Action/Type: '$col1', CIDR/Domain: '$col2'"
    
    # Handle REMOVE directives
    if [[ "$col1" == "REMOVE" ]]; then
        log_debug "Line $line_num: Skipping REMOVE directive for: $col2"
        continue
    fi
    
    # For add directives or direct CIDR entries
    if [[ "$col1" == "add" ]] || [[ "$col1" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$ ]]; then
        # Domains are in col2 and rest when col1 is "add"
        # Domains are in rest when col1 is a CIDR
        
        domains_to_process=""
        
        if [[ "$col1" == "add" ]]; then
            # Format: add,CIDR,domain1,domain2,domain3...
            # Skip the CIDR in col2, process domains in rest
            domains_to_process="$rest"
            log_debug "Line $line_num: ADD directive - processing domains: $rest"
        else
            # Format: CIDR,domain1,domain2,domain3...
            # col1 is CIDR, domains start from col2
            domains_to_process="${col2},${rest}"
            log_debug "Line $line_num: Direct CIDR format - processing domains: ${col2},${rest}"
        fi
        
        # Process the domain list
        if [[ -n "$domains_to_process" ]]; then
            IFS=',' read -ra domain_array <<< "$domains_to_process"
            log_debug "Line $line_num: Found ${#domain_array[@]} potential domains"
            
            for domain in "${domain_array[@]}"; do
                # Remove leading/trailing whitespace
                domain=$(echo "$domain" | xargs)
                
                # Skip empty entries
                if [[ -z "$domain" ]]; then
                    continue
                fi
                
                log_debug "  Processing potential domain: '$domain'"
                
                # Skip if it looks like a CIDR range
                if [[ "$domain" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$ ]]; then
                    log_debug "  Skipping CIDR range: $domain"
                    continue
                fi
                
                # Extract parent domain (remove subdomains like mail1., mail2., etc.)
                parent_domain=$(echo "$domain" | sed -E 's/^(mail[0-9]+\.|www\.|smtp\.|pop\.|imap\.)//g' | tr -d ' ')
                
                log_debug "  Extracted parent domain: '$parent_domain'"
                
                # Skip example domains
                if [[ "$parent_domain" == *"example.com"* ]] || [[ "$parent_domain" == "example.com" ]]; then
                    log_debug "  Skipping example domain: $parent_domain"
                    continue
                fi
                
                # Skip if it looks like a header value
                if [[ "$parent_domain" =~ ^domain[0-9]+$ ]] || [[ "$parent_domain" == "ip_range" ]]; then
                    log_debug "  Skipping header-like value: $parent_domain"
                    continue
                fi
                
                # Add valid domain
                if [[ -n "$parent_domain" ]] && [[ "$parent_domain" != "" ]]; then
                    if [[ -z "${unique_domains[$parent_domain]:-}" ]]; then
                        unique_domains["$parent_domain"]=1
                        log_info "  Added domain: $parent_domain"
                    else
                        log_debug "  Domain already in list: $parent_domain"
                    fi
                fi
            done
        fi
    fi
done < "$INPUT_CSV"

domain_count=${#unique_domains[@]}
log_info "Found $domain_count unique domains to process"

if [[ $domain_count -gt 0 ]]; then
    log_debug "Domains found: ${!unique_domains[*]}"
fi

if [[ $domain_count -eq 0 ]]; then
    log_warn "No valid domains found to process"
    log_info "Please add real domains to input/new.csv in format:"
    log_info "  CIDR,domain1.com,domain2.com,domain3.com"
    log_info "  OR"
    log_info "  add,CIDR,domain1.com,domain2.com,domain3.com"
    echo ""
    echo "Example new.csv content:"
    echo "192.168.1.0/24,realdomain1.com,realdomain2.com,realdomain3.com"
    exit 0
fi

# Step 4: Initialize tracking JSON
log_info "Initializing DKIM tracking file..."
cat > "$DKIM_TRACKING" << EOF
{
  "generated": "$TIMESTAMP",
  "selector": "$SELECTOR",
  "key_size": $KEY_SIZE,
  "domains": {
EOF

log_debug "Created tracking file header at: $DKIM_TRACKING"

first_domain=true

# Step 5: Generate DKIM keys for each domain
log_info "Starting DKIM key generation for $domain_count domains..."
generated_count=0
skipped_count=0
failed_count=0

for domain in "${!unique_domains[@]}"; do
    log_info "[$((generated_count + skipped_count + failed_count + 1))/$domain_count] Processing: $domain"
    
    # Sanitize domain name for filesystem (shouldn't be needed for valid domains)
    safe_domain=$(echo "$domain" | tr '/' '_')
    
    private_key_path="$KEYS_DIR/private/${SELECTOR}.${safe_domain}.pem"
    public_key_path="$PUBLIC_KEYS_DIR/${SELECTOR}.${safe_domain}.pem"
    
    if [[ -n "$PMTA_KEYS_DIR" ]]; then
        pmta_key_path="$PMTA_KEYS_DIR/${SELECTOR}.${safe_domain}.pem"
    else
        pmta_key_path=""
    fi
    
    log_debug "  Private key path: $private_key_path"
    log_debug "  Public key path: $public_key_path"
    log_debug "  PMTA key path: ${pmta_key_path:-'Not available'}"
    
    # Check if key already exists
    key_exists=false
    if [[ -f "$private_key_path" ]]; then
        log_debug "  Found existing private key at: $private_key_path"
        key_exists=true
        
        # Check key size
        log_debug "  Checking existing key size..."
        existing_size=$(openssl rsa -in "$private_key_path" -text -noout 2>/dev/null | grep "Private-Key:" | grep -oE '[0-9]+' | head -1)
        
        if [[ "$existing_size" == "$KEY_SIZE" ]]; then
            log_info "  ✓ Existing key is already $KEY_SIZE bits, skipping regeneration"
            skipped_count=$((skipped_count + 1))
            
            # Extract public key for tracking
            if openssl rsa -in "$private_key_path" -pubout -out "$public_key_path" 2>>"$DEBUG_LOG"; then
                log_debug "  ✓ Extracted public key from existing private key"
            else
                log_error "  ✗ Failed to extract public key from existing private key"
                failed_count=$((failed_count + 1))
                continue
            fi
        else
            log_warn "  Existing key is $existing_size bits (need $KEY_SIZE bits), regenerating..."
            
            # Backup old key
            backup_name="${private_key_path}.backup_${TIMESTAMP}"
            cp "$private_key_path" "$backup_name"
            log_debug "  Backed up old key to: $backup_name"
            key_exists=false
        fi
    fi
    
    if [[ "$key_exists" == "false" ]]; then
        log_info "  Generating new $KEY_SIZE bit key for $domain"
        
        # Generate private key
        log_debug "  Running: openssl genrsa -out $private_key_path $KEY_SIZE"
        if openssl genrsa -out "$private_key_path" $KEY_SIZE 2>>"$DEBUG_LOG"; then
            log_debug "  ✓ Private key generated successfully"
        else
            log_error "  ✗ Failed to generate private key"
            failed_count=$((failed_count + 1))
            continue
        fi
        
        # Extract public key
        log_debug "  Extracting public key..."
        if openssl rsa -in "$private_key_path" -pubout -out "$public_key_path" 2>>"$DEBUG_LOG"; then
            log_debug "  ✓ Public key extracted successfully"
        else
            log_error "  ✗ Failed to extract public key"
            failed_count=$((failed_count + 1))
            continue
        fi
        
        # Copy to PowerMTA directory if available
        if [[ -n "$pmta_key_path" ]]; then
            log_debug "  Copying to PowerMTA directory..."
            if sudo cp "$private_key_path" "$pmta_key_path" 2>>"$DEBUG_LOG"; then
                log_debug "  ✓ Copied to PowerMTA directory"
                
                # Set permissions
                if [[ "$SKIP_CHOWN" == "false" ]]; then
                    if sudo chown pmta:pmta "$pmta_key_path" 2>>"$DEBUG_LOG"; then
                        log_debug "  ✓ Set ownership to pmta:pmta"
                    else
                        log_warn "  Could not set ownership"
                    fi
                fi
                sudo chmod 600 "$pmta_key_path" 2>>"$DEBUG_LOG"
            else
                log_warn "  Could not copy to PowerMTA directory"
            fi
        fi
        
        generated_count=$((generated_count + 1))
    fi
    
    # Process public key for DNS record
    log_debug "  Processing public key for DNS record..."
    
    if [[ ! -f "$public_key_path" ]]; then
        log_error "  Public key file not found: $public_key_path"
        failed_count=$((failed_count + 1))
        continue
    fi
    
    # Strip header, footer, and newlines to create DNS-ready public key
    dns_public_key=$(cat "$public_key_path" | \
        sed '/-----BEGIN PUBLIC KEY-----/d' | \
        sed '/-----END PUBLIC KEY-----/d' | \
        tr -d '\n')
    
    log_debug "  Public key length: ${#dns_public_key} characters"
    
    # Save DNS record format
    dns_record_file="$KEYS_DIR/dns_records/${SELECTOR}._domainkey.${safe_domain}.txt"
    echo "\"v=DKIM1; k=rsa; p=${dns_public_key}\"" > "$dns_record_file"
    log_debug "  ✓ DNS record saved to: $dns_record_file"
    
    # Add to tracking JSON
    if [[ "$first_domain" == "false" ]]; then
        echo "," >> "$DKIM_TRACKING"
    fi
    first_domain=false
    
    cat >> "$DKIM_TRACKING" << EOF
    "$domain": {
      "selector": "$SELECTOR",
      "private_key_path": "${pmta_key_path:-$private_key_path}",
      "backup_key_path": "$private_key_path",
      "public_key_path": "$public_key_path",
      "dns_record_file": "$dns_record_file",
      "public_key": "$dns_public_key",
      "generated_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    }
EOF
    
    log_debug "  ✓ Added to tracking JSON"
done

# Close tracking JSON
cat >> "$DKIM_TRACKING" << EOF

  }
}
EOF

log_info "DKIM tracking data saved to: $DKIM_TRACKING"
log_debug "Tracking file size: $(stat -c%s "$DKIM_TRACKING" 2>/dev/null || echo 'unknown') bytes"

# Validate JSON
if command -v jq &> /dev/null; then
    if jq . "$DKIM_TRACKING" > /dev/null 2>&1; then
        log_debug "✓ Tracking JSON is valid"
    else
        log_error "✗ Tracking JSON is invalid!"
    fi
else
    log_debug "jq not installed, skipping JSON validation"
fi

# Step 6: Update or create DKIM module
log_info "Updating DKIM module for orchestrator..."

module_path="$PROJECT_ROOT/modules/dkim_generator.sh"
cat > "$module_path" << 'DKIM_MODULE'
#!/bin/bash
# DKIM Generator Module
# Fixed version - Integrated with orchestrator

set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
DKIM_DATA="$PROJECT_ROOT/output/dkim_data.json"

if [[ ! -f "$DKIM_DATA" ]]; then
    echo "Error: DKIM data not found. Run DKIM integration first."
    exit 1
fi

echo "DKIM Key Status:"
echo "================"
echo ""

# Display summary
if command -v jq &> /dev/null; then
    domain_count=$(jq '.domains | length' "$DKIM_DATA")
    echo "Total domains with DKIM: $domain_count"
    echo ""
    echo "Domains configured:"
    jq -r '.domains | keys[]' "$DKIM_DATA" | while read -r domain; do
        echo "  ✓ $domain"
    done
else
    domain_count=$(grep -c '"selector":' "$DKIM_DATA")
    echo "Total domains with DKIM: $domain_count"
fi

echo ""
echo "Key Locations:"
echo "  PowerMTA: /etc/pmta/domainkeys/"
echo "  Backups: $PROJECT_ROOT/output/keys/private/"
echo "  DNS Records: $PROJECT_ROOT/output/keys/dns_records/"
echo ""
echo "Tracking data: $DKIM_DATA"
DKIM_MODULE

chmod +x "$module_path"
log_info "DKIM module updated at: $module_path"

# Step 7: Summary
echo ""
echo "========================================="
echo "DKIM Integration Summary (Fixed)"
echo "========================================="

if [[ $domain_count -gt 0 ]]; then
    echo -e "${GREEN}✓ Successfully processed $domain_count domains${NC}"
    [[ $generated_count -gt 0 ]] && echo -e "${GREEN}✓ Generated $generated_count new keys${NC}"
    [[ $skipped_count -gt 0 ]] && echo -e "${YELLOW}→ Skipped $skipped_count existing keys${NC}"
    [[ $failed_count -gt 0 ]] && echo -e "${RED}✗ Failed $failed_count keys${NC}"
else
    echo -e "${YELLOW}No domains were processed${NC}"
fi

echo ""
echo "Key Locations:"
[[ -n "${PMTA_KEYS_DIR:-}" ]] && echo "  PowerMTA: $PMTA_KEYS_DIR"
echo "  Backups: $KEYS_DIR/private/"
echo "  Public: $PUBLIC_KEYS_DIR"
echo "  DNS Records: $KEYS_DIR/dns_records/"
echo ""
echo "Tracking File:"
echo "  $DKIM_TRACKING"
echo ""
echo "Logs:"
echo "  Main: $LOG_FILE"
[[ "$DEBUG" == "true" ]] && echo "  Debug: $DEBUG_LOG"

if [[ $domain_count -gt 0 ]]; then
    echo ""
    echo "Next Steps:"
    echo "1. Verify keys in $PMTA_KEYS_DIR"
    echo "2. Run Script 4 to generate infrastructure.json"
    echo "3. Add DNS records from $KEYS_DIR/dns_records/"
else
    echo ""
    echo "Next Steps:"
    echo "1. Add real domains to input/new.csv"
    echo "2. Re-run this script"
fi

echo "========================================="

log_info "DKIM integration completed"
log_info "Summary: Processed=$domain_count, Generated=$generated_count, Skipped=$skipped_count, Failed=$failed_count"

# Display sample DNS record if any were generated
if [[ $domain_count -gt 0 ]] && [[ -d "$KEYS_DIR/dns_records" ]]; then
    sample_file=$(ls "$KEYS_DIR/dns_records/" 2>/dev/null | head -1)
    if [[ -n "$sample_file" ]]; then
        sample_domain=$(echo "$sample_file" | sed 's/^key1\._domainkey\.//' | sed 's/\.txt$//')
        echo ""
        echo "Sample DNS Record for $sample_domain:"
        echo "  Name: ${SELECTOR}._domainkey"
        echo "  Type: TXT"
        echo "  Value: $(head -c 100 "$KEYS_DIR/dns_records/$sample_file" 2>/dev/null)..."
    fi
fi

# Final debug information
if [[ "$DEBUG" == "true" ]]; then
    echo ""
    echo "Debug Information:"
    echo "  Total lines processed: $line_num"
    [[ "$header_detected" == "true" ]] && echo "  Header row: Detected and skipped"
    echo "  Debug log lines: $(wc -l < "$DEBUG_LOG" 2>/dev/null || echo 0)"
    echo "  Disk usage: $(du -sh "$KEYS_DIR" 2>/dev/null | cut -f1 || echo 'N/A')"
fi

exit 0
